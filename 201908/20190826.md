# Documents

    - TIPS - jsp 

## StringUtils의 isNotBlank 메서드로 웹 요청 리스트 처리하기

https://baekjungho.github.io/jsp-clickadd/ <- 추가 버튼 클릭 시 태그요소 추가 이미지 따오기

위 처럼 태그요소를 추가하는 버튼이 있을 경우, 버튼으로 추가되는 태그는 대부분 LIST의 속성을 가집니다.

즉, JSP로 구현하면 아래와 비슷한 구조입니다.

```html 
<input type="hidden" name="questList[${questIndex}].questNo" id="questNo" value="<c:out value='${quest.questNo }'/>" />
<input type="hidden" name="questList[${questIndex}].content" id="content" value="<c:out value='${quest.content }'/>" />
<input type="hidden" name="questList[${questIndex}].questionNo" id="questionNo" value="<c:out value='${quest.questionNo }'/>" />
```

만약에 버튼을 3번 클릭하여 input text 태그를 3개 생성하고 나서, 가운데 input text를 삭제하는 경우, 자바에서 일반적인 List 개념으로는 List 삭제시 인덱스가 자동으로 조정이 됩니다. 즉, 인덱스 `0 1 2` 가 있을 때 1을 삭제하면, 인덱스2가 1로 바뀝니다. 하지만 JSP에서 위 처럼 강제로 List를 할당하는 경우에는 인덱스 1을 삭제하여도 `0 null 2`로 바뀌게 됩니다.

> 참고 : [자바 ArrayList의 특징](https://baekjungho.github.io/java-collection/#arraylist)

따라서 [StringUtils의 isNotBlank](https://baekjungho.github.io/apache-commonslang/#stringutils)를 사용하여 널값을 체크해서 null이 아닌 값들만 DB에 들어가게끔 만들어야 합니다. 이 로직은 `ServiceImpl`에서 구현하면 됩니다.


```java
private void createXXX(int seq, List<MinwonAddrVo> minwonAddrVoList) {
    if(!minwonAddrVoList.isEmpty()) {
        for (MinwonAddrVo minwonAddrVo : minwonAddrVoList) {
            if(StringUtils.isNotBlank(minwonAddrVo.getUrlTitle()) || StringUtils.isNotBlank(minwonAddrVo.getUrl())) {
                /*
                    StringUtils.isNotBlank로 빈문자열과 널값을 체크하는 이유
                    https://baekjungho.github.io/jsp-weblist/
                    */
                minwonAddrVo.setMinwonSeq(seq);
                minwonAddrRepository.createMinwonAddr(minwonAddrVo);
            }
        }
    }
}
```

위 처럼 ServiceImpl을 구현하게 되면, `input text로 입력받는 속성` (여기에서는 title,과 url)을 null값 체크를 하여, null이 아닌 값들만 DB에 들어가게 하면 됩니다.


## 엔티티, VO, DTO 

- 엔티티 : DB 테이블에 있는 컬럼들만 속성으로 가져야함 (extends 사용 X)

```java 
class Article {
    private Long id;
    private String title;
    private String contents;
    private Date createAt;
}
```

- VO : Value Object : equalse 메서드랑 hashCode 메서드를 구현해줘야함(extends로 BaseVo 상속 가능)

```java 
class ArticleVO {
    private Long id;
    private String title;
    private String contents;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Article article = (Article) o;
        return Objects.equals(id, article.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}
```

id, title, contents의 속성 값들이 모두 일치해야 같은 객체임

- DTO : Data Transfer Object : DB 컬럼 + 추가로 필요한 컬럼등을 이용하여 가공해야 할 때

```java 
class ArticleDTO {
    static class Create {
        private String title;
        private String contents;
        private String a;
    }

    static class Update {
        private Long id;
        private String title;
        private String contents;
    }

    static class Response {
        private Long id;
        private String title;
        private String contents;
        private Date createAt;
    }
}
```

## 리팩토링

    조건문이나 반복문이 있을 경우 어떻게 없애야 할지 고민

## @ConfigurationProperties를 이용한 properties 파일 값 바인딩, @Value를 이용한 properties 파일 값 바인딩

- application.yml or application.properties 

```yml
# 카테고리 일련번호
category:
schedule:
    seq: 9
pdfviewer:
    seq: 12
minwon:
    field: 35
    dept: 53
```

- 컨트롤러에서 스프링의 @Value 어노테이션 이용 
    - pdfviewer Controller에서 @Value 어노테이션 이용

    ```java 
    @Value("${category.pdfviewer.seq}")
	private Integer scheduleCategorySeq;
    ```

    > @Value 어노테이션은 properties 파일에 있는 값을 가져와서, 속성에 주입할 수 있다

- @ConfigurationProperties를 이용한 properties 파일 값 바인딩

    클래스 위에 @ConfigurationProperties를 사용하면 properties 파일에 있는 값을 바인딩 할 수 있다.

    - @ConfigurationProperties가 적용된 클래스 

    ```java
    @Component
    @ConfigurationProperties("category.minwon")
    @Getter
    @Setter
    public class MinwonCategories {
        private String dept;
        private String field;
    }
    ```

    - 컨트롤러

    ```java 
    private final MinwonCategories minwonCategories;
    // 생략
    List<MecCategoryVo> minwonDept = categoryService.findParentCategoriesString(minwonCategories.getDept());
    List<MecCategoryVo> minwonField = categoryService.findParentCategoriesString(minwonCategories.getField());
    ```

## Validator 사용 시 (Bean Validation에 대한 문서화)

    Validator는 필수값에 대해서 정규식이나 패턴을 검증을 할 때 사용, 등록페이지에서 등록 버튼 클릭 시 js를 통해 1차 검증을 마친 후 form으로 컨틀롤러의 @Postmapping이 적용된 create HandlerMetod를 타게 된다. 이때 

    메서드의 파라미터에 @ModelAttribute("XXXVo") XXXVo xxxVo가 선언되어있는데, @ModelAttribute의 키값 으로 설정한 XXXVO 이름이 등록페이지로 가는 @GetMapping("/form")이 적용된 HandlerMethod의 @ModelAttribute의 키값과 동일하게 되면, 등록 페이지가 제대로 로딩되지 않습니다.(단, JSP에서 @ModelAttribute의 키값으로 값을 출력하는 등의 사용이 있는 경우) 따라서
    @ModelAttribute의 키값을 다르게 해줘야 합니다. 

    ```java
    @Override
    public boolean supports(Class<?> aClass) {
        // return 클래스명.class.isAssignableFrom(aClass);
        // 해당 클래스명이 Validation을 적용할 클래스 라는 것을 명시
        // 아래 코드 처럼 사용 안하고 return false 사용 시 에러발생
        return MinwonVo.class.isAssignableFrom(aClass);
    }
    ```