## js

```javascript
const SATISFACTION_BASE_URL = `${CONTEXT_PATH}/${siteCode}/satisfaction/api`;

const executeWrite = {
	form: $('#writeForm'),
	async ajaxWrite(userMenuSeq) {
		const formData = $(executeWrite.form).serializeObject();
		if (!formData.score) {
			return alert('만족도를 선택해 주세요.');
		}
		formData.userMenuSeq = userMenuSeq;
		console.dir(formData);
		try {
			const result = await requestCreateSatisFaction(formData);
			alert('만족도 조사에 응해주셔서 감사합니다.');
			executeWrite.form[0].reset();
		} catch (e) {
			console.error(e);
			alert(validateResult(e.responseJSON));
			alert("평가 제출이 실패했습니다.");
		}
	},
};

const requestCreateSatisFaction = (data) => {
	console.dir(data);
	return new Promise ((resolve, reject) => {
		$.ajax({
			url: `${SATISFACTION_BASE_URL}/write`,
			data: data,
			method: 'POST',
		})
		.done(res => resolve(res))
		.fail(err => reject(err));
	});
}
```

## impl

```java
@Service
@RequiredArgsConstructor
public class MecSatisfactionServiceImpl extends EgovAbstractServiceImpl implements MecSatisfactionService {
	
	private final MecSatisfactionRepository satisfactionRepository;

	/**
	 * 만족도 조사 생성
	 * @param satisfactionVo
	 */
	@Override
	public void createSatisfaction(MecSatisfactionVo satisfactionVo) {
		if(satisfactionVo == null) {
			throw new NotFoundContentsException("해당하는 만족도 조사가 없습니다.");
		}
		satisfactionRepository.createSatisfaction(satisfactionVo);

	}

}
```

## RestController

```java
@RestController
@RequestMapping("/{siteCode}/satisfaction/api")
@RequiredArgsConstructor
public class MecSatisfactionRestController {

    private final MecSatisfactionService satisfactionService;

    /**
     * 등록에 성공
     * 비동기 처리도 필수 값에 대해서는 Validation을 잡아야한다.
     * 실제로 등록하기 위해서 필요한 값들만 Dto에 넣어서, 불필요한 값들에 대한 처리가 없게 만든다.
     * createStatisfaction()은 Vo를 파라미터로 받으므로, 빌더 패턴을 이용해서 DTO -> VO 변환
     * HttpSession 적용
     * - 키값 : SATISFACTION_ID 하나만 사용해도 서버에서 사용자(클라이언트)에게 set-cookie 값으로
     * - 임의의 긴 문자열인 session-id를 발행
     * @param satisfactionCreateDto
     * @param result
     * @param session
     * @return
     */
    @PostMapping("/write")
    public ResponseEntity create(@Valid MecSatisfactionCreateDto satisfactionCreateDto,
                                 BindingResult result, HttpSession session) {
        if (result.hasErrors()) { // 발리데이션에 실패 했을경우
            ErrorResponse errorResponse = new ErrorResponse(ErrorCode.BAD_REQUEST, result.getFieldErrors());
            return ResponseEntity.badRequest().body(errorResponse);
        }

        if((Integer)session.getAttribute("SATISFACTION_ID") == satisfactionCreateDto.getUserMenuSeq()) {
            return ResponseEntity.badRequest().body(ErrorCode.BAD_REQUEST);
        } else {
            session.setAttribute("SATISFACTION_ID", satisfactionCreateDto.getUserMenuSeq());
            MecSatisfactionVo satisfactionVo = satisfactionCreateDto.toEntity();
            satisfactionService.createSatisfaction(satisfactionVo);
            return ResponseEntity.ok().body("true");
        }
    }

    /**
     * 등록에 실패
     * @return
     */
    @ExceptionHandler(NotFoundContentsException.class)
    public ResponseEntity notFountSatisfaction() {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body("false");
    }
}
```

## dto

```java
@Getter @Setter
public class MecSatisfactionCreateDto {

    @NotBlank(message = "사이트 코드는 빈 값이 올 수 없습니다.")
    private String siteCode;

    @NotNull(message = "사용자 메뉴 번호는 빈 값이 올 수 없습니다.")
    private Integer userMenuSeq;

    @Min(value = 1, message = "만족도 수치가 잘못 되었습니다.")
    private int score;

    private String content;

    public MecSatisfactionVo toEntity () {
        return MecSatisfactionVo.builder()
                .siteCode(this.siteCode)
                .userMenuSeq(this.userMenuSeq)
                .score(this.score)
                .content(this.content)
                .build();
    }
}
```

## 쿼리스트링과 PathVariable

쿼리스트링(localhost:8080/xxx?mno=10)이면 ${param.mno}로 찍어야 하고

PathVariable(loalhost:8080/xxx/10)이면 ${mno}로 찍으면 된다.

## 비동기

비동기를쓸 때 $.ajax() 방식은 구식이다, 무조건 Promise를 사용하는게 좋다.

$.ajax() 방식으로 쓰는 경우에, URL을 쿼리 스트링 방식으로 넘겨주면 메서드를 get 방식으로 해야하며

POST 방식으로 넘기고 싶은 경우는 

```javascript
form: $('#writeForm'),
const formData = $(executeWrite.form).serializeObject();
```

formData를 이용하면 된다. 즉, writeForm안에있는 radio, input 등 값들이 formData에 객체 형식으로 담긴다.

그리고 비동기 처리를 할때 RestController에서 필수값에 대한 검증을 해야한다. 

VO에 a~z까지의 속성이 있는데, 실제로 등록해야하는 속성은 a~c일경우, a~c를 속성으로가지는 dto를 만들어 가공해서 보내야한다.

## @Builder

빌더 패턴을 적용하여 dto를 vo로 변환 시키기 위해서는 vo에서 @Builder가 적용된 생성자가 있어야 한다.

```java
// 각종 필요한 속성 + 추가된 속성
	@Builder
	public SatisfactionVo(Integer satisfactionSeq, String siteCode, Integer userMenuSeq, int score, String content, String menuName) {
		this.satisfactionSeq = satisfactionSeq;
		this.siteCode = siteCode;
		this.userMenuSeq = userMenuSeq;
		this.score = score;
		this.content = content;
		this.menuName = menuName;
	}
```

그리고 dto 클래스에서 vo로 변환하기 위해 아래처럼 사용하면 된다.

```java
// 필요한 속성들만 추려서 변환할 수 있다.
    public MecSatisfactionVo toEntity () {
        return MecSatisfactionVo.builder()
                .siteCode(this.siteCode)
                .userMenuSeq(this.userMenuSeq)
                .score(this.score)
                .content(this.content)
                .build();
    }
```

vo를 entity 클래스로 쓰는 것은 썩 좋은 방법은 아니지만, vo를 entity처럼 쓰고 있을 경우 해당 클래스에는 @NotNull과 같은 Validation 체크를 위한 어노테이션을 쓰면 안된다. JPA를 쓸 경우 엔티티클래스는 깔끔해야함

그래서 등록에서 필요한 값들만 dto로 추려서 필수값에 대해서 어노테이션으로 Validation 체크를 하면 된다.

비동기 처리도 필수 값에 대한 Validation을 잡아야 한다.
실제로 등록하기 위해서 필요한 값들만 Dto에 넣어서, 불필요한 값들에 대한 처리가 없게 만든다.
createStatisfaction()은 Vo를 파라미터로 받으므로, 빌더 패턴을 이용해서 DTO -> VO 변환

## HttpSession 동작 방식

https://okky.kr/article/498323

https://mohwaproject.tistory.com/entry/HTTP-Session-%EC%9D%B4%EB%9E%80